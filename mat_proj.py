# -*- coding: utf-8 -*-
"""mat_proj.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12ykaf3jGgM1DKSBLpCvmHXzH1QEwH_ig

Code that gives exact graph as paper.
"""

from math import sqrt
import numpy as np
import matplotlib.pyplot as plt
import random
from scipy.stats import norm

'''
Units:

s_r: a.u / sec
s_d: sec
ts: min
u1,u2: a.u. / sec
pb1,pb2: no unit
one_shot_det, two_shot_det : a.u. / sec
zeta: a.u. / sec

'''

def sigma_gen():
    s_rate = random.uniform(0.05,0.1)
    s_delay = 10 #(random.random() + 1) * 10

    return s_rate, s_delay

def signal_gen():
    return random.uniform(0.2,0.8)

def ts_gen():
    alpha = random.random() / 10
    ts = random.uniform(0,0.2/alpha)
    return ts

def q_func(n):
    return 1 - norm.cdf(n)

def one_shot_sigma(s_r,s_d,ts,u):
    return sqrt(s_r ** 2 + ((u/ts) * s_d) ** 2 + ((s_r * s_d) / ts) ** 2)

def two_shot_sigma(s_r,s_d,ts,u):
    return sqrt(s_r ** 2 + (((u/ts) * s_d) ** 2) / 2 + (((s_r * s_d) / ts) ** 2) / 2)

def pb(zeta, u1, s1, u2, s2):
    return (q_func((zeta-u1)/s1) + q_func((u2-zeta)/s2)) / 2

def loop(s_r,s_d,ts):
    u1 = 0.1 #signal_gen()
    u2 = signal_gen()

    zeta = (u1+u2) / 2

    pb1 = pb(zeta, u1, one_shot_sigma(s_r,s_d,ts,u1), u2, one_shot_sigma(s_r,s_d,ts,u2))
    pb2 = pb(zeta, u1, two_shot_sigma(s_r,s_d,ts,u1), u2, two_shot_sigma(s_r,s_d,ts,u2))

    return pb1, pb2, zeta

def plot_data(n=1000):
    #sigma_gen()
    s_r = 0.05
    s_d = 10
    ts = 10*60#ts_gen()

    one_shot_pb = np.zeros(n, dtype=np.float64)
    two_shot_pb = np.zeros(n, dtype=np.float64)
    zeta_arr = np.zeros(n, dtype=np.float64)

    for i in range(n):
        pb1,pb2,zeta = loop(s_r,s_d,ts)
        one_shot_pb[i] = pb1
        two_shot_pb[i] = pb2
        zeta_arr[i] = zeta

    return one_shot_pb,two_shot_pb,zeta_arr

def plotter(one_shot_pb,two_shot_pb,zeta_arr):

    plt.yscale("log")
    plt.xlabel("Threshold")
    plt.ylabel("Bit Error Rate") 
    plt.scatter(zeta_arr, one_shot_pb)
    plt.show()


def main():

    a,b,c = plot_data()
    plotter(a,b,c)
    return

if __name__ == '__main__':
    main()

"""# New Section

A more flexible code.
"""

from math import sqrt
import numpy as np
import matplotlib.pyplot as plt
import random
from scipy.stats import norm

'''
Units:

s_r: a.u / sec
s_d: sec
ts: min
u1,u2: a.u. / sec
pb1,pb2: no unit
one_shot_det, two_shot_det : a.u. / sec
zeta: a.u. / sec

'''

def sigma_gen():
    '''

    Generates σrate and σdelay randomly.

    ## Range
    σrate: 0 - 0.01
    σdelay: 10 - 20

    '''
    s_rate = random.random()/10
    s_delay = (random.random() + 1) * 10

    return s_rate, s_delay

def ts_gen():
    '''
    Generates Sampling time according to the range given in article.
    '''

    alpha = random.uniform(0.0002,0.0005) # Range: 0.0002 - 0.0005

    '''
    Ts <= 0.2/alpha
    '''

    ts = random.uniform(0,0.2/alpha)
    return ts

def q_func(n):
    '''
    Returns q value of the argument
    '''
    return 1 - norm.cdf(n)


def one_shot_sigma(s_r,s_d,ts,u):
    return sqrt(s_r ** 2 + ((u/ts) * s_d) ** 2 + ((s_r * s_d) / ts) ** 2)

def two_shot_sigma(s_r,s_d,ts,u):
    return sqrt(s_r ** 2 + (((u/ts) * s_d) ** 2) / 2 + (((s_r * s_d) / ts) ** 2) / 2)

def pb(zeta, u1, s1, u2, s2):
    '''
    Returns bit error rate according to given formula:

    `Pb = 1/2 * [Q({z-u1}/s1) + Q({u2-z}/s2)]`
    '''
    return (q_func((zeta-u1)/s1) + q_func((u2-zeta)/s2)) / 2

def loop(u1,s_r,s_d,ts,u2):
    '''
    Calculates bit error rate correnspondint to zeta and u2 parameters, while
    keeping other variables constant.
    '''

    zeta = (u1+u2) / 2

    pb1 = pb(zeta, u1, one_shot_sigma(s_r,s_d,ts,u1), u2, one_shot_sigma(s_r,s_d,ts,u2))
    pb2 = pb(zeta, u1, two_shot_sigma(s_r,s_d,ts,u1), u2, two_shot_sigma(s_r,s_d,ts,u2))

    return pb1, pb2, zeta

def plot_data(n=10000):
    '''
    Returns the array of data points needed to be plotted of size given as parameter.
    '''

    # Random sigma rate and delay
    s_r, s_d = sigma_gen()

    # Random sample time
    ts = ts_gen()

    # Random constant u1
    u1 = random.uniform(0.01,0.1)

    u2 = np.linspace(0.2,0.8,n)


    print("sigma rate - ",s_r)
    print("sigma delay - ",s_d)
    print("Ts - ",ts)
    print("Mean of x1 (Ux1) - ",u1)


    one_shot_pb = np.zeros(n, dtype=np.float64)
    two_shot_pb = np.zeros(n, dtype=np.float64)
    zeta_arr = np.zeros(n, dtype=np.float64)

    for i in range(n):
        pb1,pb2,zeta = loop(u1,s_r,s_d,ts,u2[i])
        one_shot_pb[i] = pb1
        two_shot_pb[i] = pb2
        zeta_arr[i] = zeta

    return one_shot_pb, two_shot_pb, zeta_arr

def plotter(one_shot_pb, two_shot_pb, zeta_arr):

    plt.yscale("log")  
    plt.xlabel("Threshold")
    plt.ylabel("Bit Error Rate")  

    plt.plot(zeta_arr, one_shot_pb, color='blue')
    plt.plot(zeta_arr, two_shot_pb, color='red')
    
    plt.legend(['One Shot Pb', 'Two Shot Pb'])
    plt.show()


def main():

    one_shot_pb, two_shot_pb, zeta_arr = plot_data()
    plotter(one_shot_pb, two_shot_pb, zeta_arr)
    return

if __name__ == '__main__':
    main()

import numpy as np
import scipy.special
import scipy.stats
import matplotlib.pyplot as plt

def data(s):

    # generates evenly spaces values between -5 to 5 and step size 0.01
    z = np.arange(-5,5,0.01)

    # Calculates P value of corresponding z values in fig 3
    p = scipy.special.k0(abs(z)/(s)) / (3.141 * s)

    # Calculates normal distribution values of corresponding z value
    g = scipy.stats.norm.pdf(z,0,s)

    return z,p,g

def plotter(z,p,g):
    plt.plot(z,p,color='blue')
    plt.plot(z,g,'--', color='black')

    plt.show()

def main():
    s= float(input('Swrate * Swdelay: '))
    z,p,g = data(s)
    plotter(z,p,g)

    return

if __name__ == '__main__':
    main()

import numpy as np
import matplotlib.pyplot as plt
import random
from scipy.stats import norm

'''
Units:

s_r: a.u / sec
s_d: sec
ts: min
u1,u2: a.u. / sec
pb1,pb2: no unit
one_shot_det, two_shot_det : a.u. / sec
zeta: a.u. / sec

'''

def sigma_gen():
    '''

    Generates σrate and σdelay randomly.

    ## Range
    σrate: 0 - 0.01
    σdelay: 10 - 20

    '''
    s_rate = random.random()/10
    s_delay = (random.random() + 1) * 10

    return s_rate, s_delay

def ts_gen():
    '''
    Generates Sampling time according to the range given in article.
    '''

    alpha = random.uniform(0.0002,0.0005) # Range: 0.0002 - 0.0005

    '''
    Ts <= 0.2/alpha
    '''

    ts = random.uniform(0,0.2/alpha)
    return ts

def q_func(n):
    '''
    Returns q value of the argument
    '''
    return 1 - norm.cdf(n)

def pb(zeta, u1, s1, u2, s2):
    '''
    Returns bit error rate according to given formula:

    `Pb = 1/2 * [Q({z-u1}/s1) + Q({u2-z}/s2)]`
    '''
    return (q_func((zeta-u1)/s1) + q_func((u2-zeta)/s2)) / 2

def loop(u1,s_r,s_d,ts,u2):
    '''
    Calculates bit error rate correnspondint to zeta and u2 parameters, while
    keeping other variables constant.
    '''

    zeta = (u1+u2) / 2

    trig_pb = pb(zeta, u1, s_r, u2, s_r)

    return trig_pb, zeta

def plot_data(n=10000):
    '''
    Returns the array of data points needed to be plotted of size given as parameter.
    '''

    # Random sigma rate and delay
    s_r, s_d = sigma_gen()

    # Random sample time
    ts = ts_gen()

    # Random constant u1
    u1 = random.uniform(0.01,0.1)

    u2 = np.linspace(0.2,0.8,n)


    print("sigma rate - ",s_r)
    print("sigma delay - ",s_d)
    print("Ts - ",ts)
    print("Mean of x1 (Ux1) - ",u1)
    tirggered_det_pb = np.zeros(n, dtype=np.float64)
    zeta_arr = np.zeros(n, dtype=np.float64)

    # loop to process for n data points
    for i in range(n):
        pb2,zeta = loop(u1,s_r,s_d,ts,u2[i])
        tirggered_det_pb[i] = pb2
        zeta_arr[i] = zeta

    return tirggered_det_pb, zeta_arr

def plotter(two_shot_pb,zeta_arr):
    '''
    Plots the graph with proper legends and scale of given input arrays
    '''

    plt.yscale("log")  
    plt.xlabel("Threshold")
    plt.ylabel("Bit Error Rate")  

    plt.plot(zeta_arr, two_shot_pb, color='green')
    
    plt.legend(['Triggered detection Pb'])
    plt.show()


def main():

    tirggered_det_pb, zeta_arr = plot_data()
    plotter(tirggered_det_pb, zeta_arr)
    return

if __name__ == '__main__':
    main()